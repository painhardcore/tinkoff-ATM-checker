package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"reflect"
	"time"

	"github.com/fatih/color"
)

// autogenerated thing
type Point struct {
	ID    string `json:"id"`
	Brand struct {
		ID          string `json:"id"`
		Name        string `json:"name"`
		LogoFile    string `json:"logoFile"`
		RoundedLogo bool   `json:"roundedLogo"`
	} `json:"brand"`
	PointType string `json:"pointType"`
	Location  struct {
		Lat float64 `json:"lat"`
		Lng float64 `json:"lng"`
	} `json:"location"`
	Address string   `json:"address"`
	Phone   []string `json:"phone"`
	Limits  []struct {
		Currency      string `json:"currency"`
		Max           int    `json:"max"`
		Denominations []int  `json:"denominations"`
		Amount        int    `json:"amount"`
	} `json:"limits"`
	WorkPeriods []struct {
		OpenDay   int    `json:"openDay"`
		OpenTime  string `json:"openTime"`
		CloseDay  int    `json:"closeDay"`
		CloseTime string `json:"closeTime"`
	} `json:"workPeriods"`
	InstallPlace string `json:"installPlace"`
	AtmInfo      struct {
		Available  bool `json:"available"`
		IsTerminal bool `json:"isTerminal"`
		Statuses   struct {
			CriticalFailure       bool `json:"criticalFailure"`
			QrOperational         bool `json:"qrOperational"`
			NfcOperational        bool `json:"nfcOperational"`
			CardReaderOperational bool `json:"cardReaderOperational"`
			CashInAvailable       bool `json:"cashInAvailable"`
		} `json:"statuses"`
		Limits []struct {
			Currency                string `json:"currency"`
			Amount                  int    `json:"amount"`
			WithdrawMaxAmount       int    `json:"withdrawMaxAmount"`
			DepositionMaxAmount     int    `json:"depositionMaxAmount"`
			DepositionMinAmount     int    `json:"depositionMinAmount"`
			WithdrawDenominations   []int  `json:"withdrawDenominations"`
			DepositionDenominations []int  `json:"depositionDenominations"`
			OverTrustedLimit        bool   `json:"overTrustedLimit"`
		} `json:"limits"`
	} `json:"atmInfo"`
}
type Tinkoffresponse struct {
	TrackingID string `json:"trackingId"`
	Payload    struct {
		Hash   string `json:"hash"`
		Zoom   int    `json:"zoom"`
		Bounds struct {
			BottomLeft struct {
				Lat float64 `json:"lat"`
				Lng float64 `json:"lng"`
			} `json:"bottomLeft"`
			TopRight struct {
				Lat float64 `json:"lat"`
				Lng float64 `json:"lng"`
			} `json:"topRight"`
		} `json:"bounds"`
		Clusters []struct {
			ID     string `json:"id"`
			Hash   string `json:"hash"`
			Bounds struct {
				BottomLeft struct {
					Lat float64 `json:"lat"`
					Lng float64 `json:"lng"`
				} `json:"bottomLeft"`
				TopRight struct {
					Lat float64 `json:"lat"`
					Lng float64 `json:"lng"`
				} `json:"topRight"`
			} `json:"bounds"`
			Center struct {
				Lat float64 `json:"lat"`
				Lng float64 `json:"lng"`
			} `json:"center"`
			Points []Point `json:"points"`
		} `json:"clusters"`
	} `json:"payload"`
	Time   time.Time `json:"time"`
	Status string    `json:"status"`
}

// autogenerated
type ATMReq struct {
	Bounds struct {
		BottomLeft struct {
			Lat float64 `json:"lat"`
			Lng float64 `json:"lng"`
		} `json:"bottomLeft"`
		TopRight struct {
			Lat float64 `json:"lat"`
			Lng float64 `json:"lng"`
		} `json:"topRight"`
	} `json:"bounds"`
	Filters struct {
		Banks           []string `json:"banks"`
		ShowUnavailable bool     `json:"showUnavailable"`
		Currencies      []string `json:"currencies"`
	} `json:"filters"`
	Zoom int `json:"zoom"`
}

func main() {
	store := make(map[string]Point)
	monitor(store)
	for range time.Tick(time.Second * 15) {
		monitor(store)
	}

}

func monitor(store map[string]Point) {
	question := &ATMReq{
		Bounds: struct {
			BottomLeft struct {
				Lat float64 "json:\"lat\""
				Lng float64 "json:\"lng\""
			} "json:\"bottomLeft\""
			TopRight struct {
				Lat float64 "json:\"lat\""
				Lng float64 "json:\"lng\""
			} "json:\"topRight\""
		}{BottomLeft: struct {
			Lat float64 "json:\"lat\""
			Lng float64 "json:\"lng\""
		}{Lat: 59.69666446923786, Lng: 29.99264270868952}, // from map
			TopRight: struct {
				Lat float64 "json:\"lat\""
				Lng float64 "json:\"lng\""
			}{Lat: 60.12665086731634, Lng: 30.597577401072314}}, // from map
		Filters: struct {
			Banks           []string "json:\"banks\""
			ShowUnavailable bool     "json:\"showUnavailable\""
			Currencies      []string "json:\"currencies\""
		}{
			Banks:           []string{"tcs"}, // only tinkoff
			ShowUnavailable: true,
			Currencies:      []string{"USD"}, // change
		},
		Zoom: 11, // from map
	}
	postBody, err := json.Marshal(question)

	if err != nil {
		log.Fatal(err)
	}

	responseBody := bytes.NewBuffer(postBody)

	client := http.Client{}
	req, err := http.NewRequest("POST", "https://api.tinkoff.ru/geo/withdraw/clusters", responseBody)
	if err != nil {
		log.Fatal(err)
	}

	req.Header = http.Header{
		"Content-Type": []string{"application/json; charset=UTF-8"},
	}
	resp, err := client.Do(req)
	if err != nil {
		//Handle Error
		log.Fatal(err)
	}
	defer resp.Body.Close()

	//We Read the response body on the line below.
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalln(err)
	}
	tresponse := &Tinkoffresponse{}
	if err := json.Unmarshal(body, &tresponse); err != nil {
		panic(err)
	}

	for _, cluster := range tresponse.Payload.Clusters {
		for _, point := range cluster.Points {
			d := color.New(color.FgHiWhite)
			if prev, ok := store[point.ID]; !ok {
				d = color.New(color.FgHiGreen, color.Bold)
				store[point.ID] = point
			} else {
				if !reflect.DeepEqual(prev, point) {
					d.DisableColor()
					d.Printf("%s\t", point.ID)
					d.Printf("%s\t", point.Address)
					for _, limit := range point.AtmInfo.Limits {
						for _, oldlimit := range prev.AtmInfo.Limits {
							if limit.Currency == oldlimit.Currency {
								switch {
								case oldlimit.Amount > limit.Amount:
									d = color.New(color.FgHiRed, color.Bold)
								case oldlimit.Amount < limit.Amount:
									d = color.New(color.FgHiMagenta, color.Bold)
								default:
									d = color.New(color.FgHiWhite, color.Bold)
								}
								d.Printf("%s:%d ", limit.Currency, limit.Amount)
							}
						}
					}
					t := time.Now()
					fmt.Print(t.Format("15:04:05"))
					d.Printf("\n")
				}
				store[point.ID] = point
				continue
			}
			d.Printf("%s\t", point.ID)
			d.Printf("%s\t", point.Address)
			for _, limit := range point.AtmInfo.Limits {
				d.Printf("%s:%d ", limit.Currency, limit.Amount)
			}
			t := time.Now()
			fmt.Print(t.Format("15:04:05"))
			d.Printf("\n")
		}
	}
}
